from typing import List
import csv
from pathlib import Path


class DataFiles:
    def __init__(self, prefix:str, output_folder_path: str, **kwargs) -> None:
        # These files will match the output logger file names from Logger.cc
        # as the prefix here is the prefix used in the logger
        self.prefix = prefix
        self.output_folder_path = output_folder_path
        self.results_file_name = kwargs.get("results_file_name", self.prefix + "_results")
        self.plot_collection_name = kwargs.get("plot_collection_name", self.prefix.capitalize())

    @property
    def results_file_path(self) -> Path:
        return Path(self.output_folder_path) / Path(self.results_file_name)

    def check_is_dynosam_results(self) -> bool:
        """
        Checks that the files that this datastructure represent actually exist (locally) and therefore is a valid
        dynosam results folder

        Returns:
            bool: Is a valid dynosam results folder
        """
        output_folder_path = Path(self.output_folder_path)

        expected_file_names = get_datafile_properties(self)
        found_file_names =  [path.name for path in output_folder_path.iterdir()]

        # check if all names are found
        all_found = set(expected_file_names) <= set(found_file_names)
        return all_found

    def plot_collection_exists(self) -> bool:
        return self.results_file_path.exists()





    @property
    def object_pose_log(self):
        return self.prefix + "_object_pose_log.csv"

    @property
    def object_motion_log(self):
        return self.prefix + "_object_motion_log.csv"

    @property
    def camera_pose_log(self):
        return self.prefix + "_camera_pose_log.csv"

    @property
    def map_point_log(self):
        return self.prefix + "_map_points_log.csv"

    def __str__(self):
        return "DataFiles [\n\tprefix: {}\n\tresult file name: {}\n\tplot collection name: {}".format(
            self.prefix,
            self.results_file_name,
            self.plot_collection_name
        )

def read_csv(csv_file_path:str, expected_header: List[str]):
    assert csv_file_path is not None
    csvfile = open(csv_file_path, 'r')
    reader = csv.DictReader(csvfile)
    try:

        try:
            header = next(reader)
            keys = list(header.keys())
            if keys != expected_header:
                raise Exception(
                    "Csv file headers were not valid when loading file at path: {}. "
                    "Expected header was {} but actual keys were {}".format(
                        csv_file_path, expected_header, keys
                    )
                )
        except StopIteration as e:
            raise Exception(f"Failed to read header in csv file {csv_file_path}. File may be empty!?")

        # reset iterator by making new reader
        csvfile = open(csv_file_path, 'r')
        return csv.DictReader(csvfile)
    except Exception as e:
        raise Exception(f"Failed to read csv file {csv_file_path}. Exception raised was {str(e)}")


def get_datafile_properties(data_files: DataFiles):
    # get functions relating to file paths of expected output logs
    # note: we dont look at ALL the possible properties of DataFiles, just the main ones
    return [
        data_files.camera_pose_log,
        data_files.object_motion_log,
        data_files.object_pose_log
    ]


def check_if_results_folder(possible_results_folder:str) -> bool:
    """
    Check if the folder path is a folder that acts as a dynosam results path.

    Args:
        possible_results_folder (str): Absolute path to a possible results folder

    Returns:
        bool: True if it cotnains some results!!
    """
    prefixes = search_for_results_prefixes(possible_results_folder)
    # if we have prefix's, assume that it is a results folder
    return len(prefixes) > 0


def search_for_results_prefixes(possible_results_folder:str) -> List[str]:
    """
    Given a path to a possible results folder find the list of possible result prefixes.

    A results folder is one generated by running DynoSAM with the evaluation (eval_launch) and stores
    all the possible output logs. The prefix's refer to the start of the log files and change depending
    on the back-end used.

    Args:
        possible_results_folder (str): Absolute path to a possible results folder

    Returns:
        List[str]: list of possible prefixes
    """
    from pathlib import Path
    output_folder_path = Path(possible_results_folder)

    path_prefix_set = set()

    dummy_data_files = DataFiles("","")

    # these strings will return the names of the output log files, the suffix of which
    # we want to find in the output_folder_path
    data_files = get_datafile_properties(dummy_data_files)

    for p in output_folder_path.iterdir():
        # p is absolute path
        if p.is_file():
            found_file_name = p.name
            # expect file name of loggers to be suffixed with the output of data_file_property_functons
            for expected_log_suffx_name in data_files:
                # found file name should be in the form prefix_suffix
                # e.g. rgbd_backend_object_pose_log.csv
                # where rgbd_backend is the prefix_we want to find
                # and _object_pose_log is a known suffux to a log file
                if found_file_name.endswith(expected_log_suffx_name):
                    possible_prefix = found_file_name.removesuffix(expected_log_suffx_name)
                    path_prefix_set.add(possible_prefix)
    return list(path_prefix_set)
